// Compilador para mapear bases de dados primitivas para formatos de redes complexas
//
// Universidade Federal do Espírito Santo
// Grupo de Pesquisa: NetKOR (Networked  Knowledge Organization Retrieval)
//
// Desenvolvedores:
// Henrique Monteiro Cristovão
// Klaus Kly Cuzzuol Wolff
// Luis Henrique Gundes Valim

options {
	DEBUG_PARSER = false;
	DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compiler)

package parser;
import setting.*;
import error.*;
import semantic.*;
import inOut.*;

import java.util.*;
import java.io.*;
import java.nio.file.Files;
import java.nio.charset.StandardCharsets;

public class Compiler {
	public static void main(String args[])  throws ParseException  {
		Compiler compiler = null;
		//========================================ESTRUTURAS DE DADOS=============================================//
		//====Estrutura - Secao 1
		//Contem as opcoes definidas no map a partir da section 1 e armazenadas no hashDefinition
		NetDefinition definition;
		//
		//====Estrutura - Secao 2
		//==VariableList - Lista que contem a definicoes das variaveis na section 2 e os nomes das colunas correspondentes
		VariableList variableList = new VariableList();
		//
		//====Estrutura - Secao 3
		//==vertexList	- Lista que armazena cada vertice definido na section 3
		ArrayList<Vertex> vertexList = new ArrayList<Vertex>();
		//
		//====Estruturas auxiliares
		//listPrimaryKeyVertices - Lista contendo todos os valores da coluna de primaryKey
		LinkedList<String> listPrimaryKeyVertices = new LinkedList<String>();
		//hashArc - Hash que armazena todos as expressoes validas para cada vertice do Csv 
		LinkedHashMap<Integer,ArrayList<Integer>> hashArcs = new LinkedHashMap<Integer,ArrayList<Integer>>();
		//HashBipartite
		LinkedHashMap<String, ArrayList<Integer>> hashBipartite = new LinkedHashMap<String,ArrayList<Integer>>();
		//HashWeight
		HashMap<ArrayList<Integer>,Integer> hashWeight = new LinkedHashMap<ArrayList<Integer>,Integer>();
		try {
			//===========================================COMPILACAO===================================================//
			compiler = new Compiler(new FileInputStream(Configuration.mapFile));
			definition = Compiler.start(variableList, vertexList);

			//------Leitura rapida do Csv para contar todas as linhas contindas no arquivo-------		
			//Metodo coutLines conta a partir de 0, portanto resulta em (valor total - 1) 
			//Com header -> Desconsidera-se o header, logo este (valor total - 1) serve
			Integer totalLinesCsv = ReaderCsv.countLines();
			//Sem header -> Como nao ha header, todas as linhas devem ser consideradas, para isso ha o incremento
			if(definition.getHeader().toLowerCase().equals("false")) totalLinesCsv++;	
			
			//========================================PRIMEIRA LEITURA DO CSV=========================================//

			ReaderCsv.readColumns(variableList, definition);
			
			//========================================SEGUNDA LEITURA DO CSV==========================================//

			ReaderCsv.readAllLines(listPrimaryKeyVertices, variableList, vertexList, totalLinesCsv,
								   hashArcs, definition, hashBipartite);

			SemanticActions.unusedVariable(variableList);
			
			if(definition.getBipartiteProjection().toLowerCase().equals("false")) {
				totalLinesCsv++;
				SemanticActions.noNetwork(hashArcs);
				WriterNet.writeAll(listPrimaryKeyVertices, vertexList, hashArcs, definition);
			//========================================ESCRITA DO ARQUIVO NET==========================================//
			}
			
			else {
				SemanticActions.preparation(hashBipartite,hashWeight);
			//========================================ESCRITA DO ARQUIVO NET==========================================//
				WriterNet.writeBipartite(vertexList, hashBipartite, hashWeight, definition);
			}	
			
			if(SemanticActions.warnings == 1 ) {
				System.out.println("\n\n***** Successful compilation with "+SemanticActions.warnings+" warning! *****");
			}
			else if(SemanticActions.warnings > 1 ) {
				System.out.println("\n\n***** Successful compilation with "+SemanticActions.warnings+" warnings! *****");
			}
			else {
				System.out.println("\n\n***** Successful compilation! *****");
			}
		}
		catch(FileNotFoundException e) {
			System.err.println("\nFile not found: ");
		}
		catch (IOException e) {
			System.err.println("File creation error: " + e.getMessage());
		}
		catch(TokenMgrError e) {
			System.err.println("\nLexical error: " + e.getMessage());
		}
		catch(ParseException e) {
			System.err.println("\nSintax error: " + e.getMessage());
		}
		catch(SemanticError e) {
			System.err.println("\nSemantic error: " + e.getMessage());
		}
	}
}

PARSER_END(Compiler)
 
SKIP : { " " | "\t" | "\r" | "\n" }

SKIP : { "#" : comentarioGeral }
<comentarioGeral> SKIP: { "\n" | "\n\r" | "\r\n" : DEFAULT | <~[]> }

//TOKENS DE SIMBOLOS
TOKEN [IGNORE_CASE] : {
	< PARENTHESIS_OPEN: "(" > |
	< PARENTHESIS_CLOSE: ")" > |	
	< BRACKET_OPEN: "[" > |
	< BRACKET_CLOSE: "]" > |
	< ELLIPSIS: "..." > |
	< SEMICOLON: ";" > |
	< COLON: ":" > |
	< EQUAL: "=" > |
	< TYPE_VARIABLE_PRIMARY: "*" > |
	< TYPE_VARIABLE_SECONDARY: ">" > |
	< LESSER: "<" > 
}

//PALAVRAS RESERVADAS
TOKEN [IGNORE_CASE] : {
	< SOURCE_FORMAT: "Source format" > |
	< TARGET_FORMAT: "Target format" > |
	< HEADER: "Header" > |
	< DIRECTED_NETWORK: "Directed network" > |
	< BIPARTITE_PROJECTION: "Bipartite projection" > |
	< LAYOUT: "Layout" > |            
	< VARIABLES: "Variables" > |
	< NETWORK: "Network" > 
}

//TOKENS DE ENTRADA PARA CONFIGURACAO
TOKEN [IGNORE_CASE] : {
	< NETWORK_FORMAT: "NET" | "PAJ" > |	//Adicionar mais formatos futuramente
	< SOURCE_FORMAT_INPUT: "CSV" > |		//Adicionar mais formatos futuramente
	< LOGIC_VALUE: "TRUE" | "FALSE" > |            
	< LAYOUT_NAME: "NOPE" > |				//Falta incluir os tipos de layout de rede
	< NO: "NO" > |
	< OR: "OR" > |
	< AND: "AND" > 
}

//----------Tokens unicos----------//
TOKEN [IGNORE_CASE] : {
	//[X...Y] / [X...Y) / (X...Y] / (X...Y)
	< FORMATELLIPSIS1: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")* < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	
	< FORMATELLIPSIS2: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")*  < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > | //[x ... y)
	< FORMATELLIPSIS3: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	//(x ... y]
	< FORMATELLIPSIS4: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |	//(x ... y)
	
	// (...X) / (...X] / [X...) / (X...)
	< FORMATELLIPSIS5: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |
	< FORMATELLIPSIS6: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <BRACKET_CLOSE >) > |
	< FORMATELLIPSIS7: ((" ")* < BRACKET_OPEN > (" ")* < OPTION >  (" ")* < ELLIPSIS > (" ")*   <PARENTHESIS_CLOSE >) > |
	< FORMATELLIPSIS8: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > (" ")* < ELLIPSIS > (" ")* <PARENTHESIS_CLOSE >) > |
	< OPTION: < NUMBERCHARACTER > | < LETTERCHARACTER  > >
}

//
TOKEN [IGNORE_CASE] : {
	< #LETTERCHARACTER: ["a" - "z"] | ["A" - "Z"] > |
	< #NUMBERCHARACTER: (["0"-"9"])* ((".")? ["0"-"9"])+ > |
	< #VARIABLECHARACTER: ["a" - "z", "A" - "Z" ,"0" - "9", "_"] > |
	< VERTEX_NAME_WITH_QUOTE_MARK: "\"" (~["\""])* "\"" > |
	< HEAD_NAME_IN_CSV_OR_VARIABLE_NAME: (< LETTERCHARACTER >) (< VARIABLECHARACTER > | "." )* > 
}

// Gramática:
//
// Start ->	section1 section 2 section 3
//
NetDefinition start(VariableList variableList, ArrayList<Vertex> vertexList) : {
	NetDefinition definition;
}
{
	definition = section1()
	section2(variableList)
	section3(vertexList, variableList)
	{
		return definition;
	}
}

// Gramática:
//
// section 1 ->	<SOURCE_FORMAT> <COLON> <SOURCE_FORMAT_INPUT>
//				<TARGET_NAME> <COLON> <NETWORK_FORMAT>
//				<DIRECTED_NETWORK> <COLON> <LOGIC_VALUE>
//				<BIPARTITE_PROJECTION> <COLON> <LOGIC_VALUE>
//				<LAYOUT> <COLON> (<LAYOUT_NAME> | <OR>)
//
//
NetDefinition section1() : {
	Token header, sourceFormat, networkFormat, directedNetwork, bipartiteProjection, networkLayout;
	NetDefinition definition;
}
{
	<SOURCE_FORMAT> <COLON> sourceFormat = <SOURCE_FORMAT_INPUT>
	<TARGET_FORMAT> <COLON> networkFormat = <NETWORK_FORMAT>
	<HEADER> <COLON> header = <LOGIC_VALUE> 
	<DIRECTED_NETWORK> <COLON> directedNetwork = <LOGIC_VALUE> 
	<BIPARTITE_PROJECTION> <COLON> bipartiteProjection = <LOGIC_VALUE>
	<LAYOUT> <COLON>
	(
		networkLayout = <LAYOUT_NAME>
		|
		networkLayout = <NO> )
  		{
  	  		definition = new NetDefinition(networkFormat.image, directedNetwork.image, bipartiteProjection.image,
						networkLayout.image, header.image, sourceFormat.image);
			return definition;
  		}
}

// Gramática:
//
// section2	->	<VARIABLES> <COLON> variableDefinition
//
void section2(VariableList variableList): { }
{
	<VARIABLES> <COLON> (variableDefinition(variableList))+
}

// Gramática:
//
// 
//
void variableDefinition(VariableList variableList):
{
  Token type, headNameInCsv, variableName = null;
  Variable variable;
}
{
	( type = <TYPE_VARIABLE_PRIMARY> | type = <TYPE_VARIABLE_SECONDARY> ) headNameInCsv = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	(
	  	<COLON> variableName = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
		{
		  	if(variableName.image.trim().isEmpty()) variableName = headNameInCsv;
		}
	)?
	{
	 	if(type.image.equals("*")) {
			variable = new Variable(headNameInCsv.image,variableName.image,VariableType.PRIMARY, type.beginLine);
		}
		else {
			variable = new Variable(headNameInCsv.image,variableName.image,VariableType.NON_PRIMARY, type.beginLine);
		}	
	  	variableList.add(variable);	
	}
}

// Gramática:
//
// 
//
void section3(ArrayList<Vertex> vertexList, VariableList variableList): { }
{
  	<NETWORK> <COLON> (vertexDefinition(vertexList, variableList))+
}

// Gramática:
//
// 
//
void vertexDefinition(ArrayList<Vertex> vertexList, VariableList variableList):
{
  Token vertexName;
}
{
		<HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	| 
		vertexName = <VERTEX_NAME_WITH_QUOTE_MARK>
		{
			Vertex vertex = new Vertex(vertexName.image);
		}
		<COLON>
		(
	  		operationOR(vertex, variableList)
			{
	  			vertexList.add(vertex);
			}
		)+
}

// Gramática:
//
// 
//	
void operationOR(Vertex expression, VariableList variableList):
{
  Token operator;
  Item item = null;
}
{
	operationAND(expression, variableList) ( operator = < OR > operationAND(expression, variableList)
	{
	  	item = new Operator(OperatorType.OR, operator.image);
		expression.add(item);
	}
	)*   
}

// Gramática:
//
// 
//
void operationAND(Vertex expression, VariableList variableList):
{
  Token operator;
  Item item = null;  
}
{
	vertexExpression(expression, variableList) ( operator = < AND > vertexExpression(expression, variableList)
	{
		item = new Operator(OperatorType.AND, operator.image);
		expression.add(item);
	}
	)*
}

// Gramática:
//
// 
//
void vertexExpression(Vertex expression, VariableList variableList):
{
  Token variable, operator, operator2;
}
{
	variable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME> (
	  												operator = <EQUAL> vertexRangeDefinition(expression, variable, operator, variableList)
													| operator = <TYPE_VARIABLE_SECONDARY>
														(
													  		operator2 = <EQUAL>
	  												  		optionDualOperator(expression, variable, operator, operator2, variableList)
	  												  		|
	  												  		option(expression, variable, operator, variableList)
	  												 	)
													| operator = <LESSER>
														(														  operator2 = <EQUAL>
	  												  	  optionDualOperator(expression, variable, operator, operator2, variableList) 
														  |
														  option(expression, variable, operator, variableList)
	  													)
												   )
}

// Gramática:
//
// 
//
void vertexRangeDefinition(Vertex expression, Token variable, Token operator, VariableList variableList):
{
  Token expressionToken;
  Item item = null;
}
{
	(
    	(
	   		expressionToken = < FORMATELLIPSIS1 > | expressionToken = < FORMATELLIPSIS2 > |
	   		expressionToken = < FORMATELLIPSIS3 > | expressionToken = < FORMATELLIPSIS4 > |
	   		expressionToken = < FORMATELLIPSIS5 > | expressionToken = < FORMATELLIPSIS6 > |
	   		expressionToken = < FORMATELLIPSIS7 > | expressionToken = < FORMATELLIPSIS8 > 
	   	)
		{
			item = new Variable(VariableType.NON_PRIMARY, variable.image, variable.beginLine);
			SemanticActions.containsVariable(item, variableList, variable.beginLine);
			expression.add(item);
			expression.addInterval(expressionToken.image, item);
	 	}
	   	|	rangeExpression(expression, variable, operator, variableList)
  	)
}

// Gramática:
//
// 
//
void rangeExpression(Vertex expression, Token variable, Token operator, VariableList variableList): { }
{
	(
		( <PARENTHESIS_OPEN> | <BRACKET_OPEN> )
		optionList(expression, variable, operator, variableList)
		( <PARENTHESIS_CLOSE> | <BRACKET_CLOSE> )
	)
	|	option(expression, variable, operator, variableList)
}

// Gramática:
//
// 
//
void option(Vertex expression, Token variable, Token operator, VariableList variableList):
{
  Token opt;
  Item item = null;
}
{
 	opt = < OPTION >
	{	
		item = new Variable(VariableType.NON_PRIMARY,variable.image, variable.beginLine);
		SemanticActions.containsVariable(item, variableList, variable.beginLine);
		expression.add(item);
		item = new Operand(OperandType.NUMBER, opt.image);
		expression.add(item);
		item = new Operator(OperatorType.EQUAL, operator.image);
		expression.add(item);
	}
}

// Gramática:
//
// 
//
void optionDualOperator(Vertex expression, Token variable, Token operator, Token operator2, VariableList variableList):
{
  Token opt;
  Item item = null;
}
{
 	opt = < OPTION >
	{	
		item = new Variable(VariableType.NON_PRIMARY,variable.image, variable.beginLine);
		SemanticActions.containsVariable(item, variableList, variable.beginLine);
		expression.add(item);
		item = new Operand(OperandType.NUMBER,opt.image);
		expression.add(item);
		item = new Operator(OperatorType.EQUAL, operator.image + operator2.image);
		expression.add(item);
	}
}

// Gramática:
//
// 
//
void optionList(Vertex expression, Token variable, Token operator, VariableList variableList):
{
  Token option;
  Item item = null;
}
{
	option = <OPTION>
   	{
   	  	item = new Variable(VariableType.NON_PRIMARY,variable.image, variable.beginLine);
		SemanticActions.containsVariable(item, variableList, variable.beginLine);
		expression.add(item);
		item = new Operand(OperandType.NUMBER,option.image);
		expression.add(item);
	  	item = new Operator(OperatorType.EQUAL,operator.image);
		expression.add(item);
	}
  	(
  		<SEMICOLON> optionList(expression,variable, operator, variableList)
  	  	{
	  		item = new Operator(OperatorType.OR,"OR");
			expression.add(item);
  	  	}
	)?
}
